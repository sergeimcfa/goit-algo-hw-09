Порівняння алгоритмів видачі решти

Жадібний алгоритм (find_coins_greedy)

Часова складність: O(N), де N — кількість номіналів монет. Оскільки кількість номіналів фіксована (6 шт.), алгоритм працює миттєво (O(1) відносно суми).

Переваги: Дуже швидкий, простий у реалізації, не потребує додаткової пам'яті.

Недоліки: Для деяких наборів монет (неканонічних) може не дати оптимального рішення (хоча для нашого набору [50, 25, 10, 5, 2, 1] він працює ідеально).

Динамічне програмування (find_min_coins)

Часова складність: O(A · N), де A — сума решти. Час виконання лінійно залежить від величини суми.

Переваги: Гарантовано знаходить мінімальну кількість монет для будь-якого набору номіналів.

Недоліки: Повільніший для великих сум. Вимагає O(A) додаткової пам'яті для таблиці результатів. Наприклад, для суми 1,000,000 потрібно створити масив на мільйон елементів, що є неефективним порівняно з жадібним підходом.

Висновок

Для даної задачі та стандартного набору монет жадібний алгоритм є більш ефективним, оскільки він завжди дає оптимальний результат за мінімальний час і без витрат пам'яті. Динамічне програмування доцільно використовувати лише для специфічних наборів монет, де жадібний підхід не працює.
