def find_min_coins(amount):
    """
    Алгоритм динамічного програмування для знаходження мінімальної кількості монет.
    
    :param amount: Сума, для якої потрібно видати решту.
    :return: Словник {номінал: кількість} з мінімальною кількістю монет.
    """
    coins = [50, 25, 10, 5, 2, 1]
    
    # Таблиця dp[i] зберігатиме мінімальну кількість монет для суми i.
    # Ініціалізуємо значенням, більшим за будь-яке можливе (amount + 1),
    # щоб потім знаходити мінімум.
    # dp[0] = 0, бо для суми 0 потрібно 0 монет.
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    # Масив для відновлення рішення: used_coins[i] зберігатиме номінал монети,
    # яка була додана останньою для досягнення суми i.
    used_coins = [0] * (amount + 1)

    # Основний цикл заповнення таблиці
    for s in range(1, amount + 1):
        for coin in coins:
            # Якщо монета не перевищує поточну суму s
            if s >= coin:
                # Перевіряємо, чи покращить використання цієї монети результат
                if dp[s - coin] + 1 < dp[s]:
                    dp[s] = dp[s - coin] + 1
                    used_coins[s] = coin

    # Якщо dp[amount] все ще нескінченність, значить суму неможливо скласти
    if dp[amount] == float('inf'):
        return {}

    # Відновлення результату (backtracking)
    result = {}
    current_sum = amount
    
    while current_sum > 0:
        # Беремо монету, яка була використана для досягнення current_sum
        coin = used_coins[current_sum]
        
        # Додаємо її в словник результату
        if coin in result:
            result[coin] += 1
        else:
            result[coin] = 1
            
        # Зменшуємо поточну суму на номінал взятої монети
        current_sum -= coin

    return result

if __name__ == "__main__":
    # Тестова сума
    amount_to_change = 113
    
    print(f"--- Динамічне програмування ---")
    print(f"Сума для розміну: {amount_to_change}")
    
    # Виклик функції
    result = find_min_coins(amount_to_change)
    
    print(f"Результат: {result}")
    # Очікується: {50: 2, 10: 1, 2: 1, 1: 1} (або аналогічний оптимальний набір)
